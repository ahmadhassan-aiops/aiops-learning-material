
SECRETS:

In Kubernetes, Secrets are used to securely store and manage sensitive information such as passwords, OAuth tokens, and SSH keys. 
Unlike plain environment variables or ConfigMaps, Secrets encode data in base64 and restrict visibility to only authorized pods and users, 
helping prevent accidental exposure. They can be consumed by pods as environment variables, mounted as volumes, or accessed via the Kubernetes API. 
By decoupling secret data from application logic, Kubernetes Secrets improve security, flexibility, and management of sensitive configuration in a cluster.



----------------------------------------
Important Notes on Kubernetes Secrets
---------------------------------------



1. Secrets are base64-encoded, not encrypted, so they are not secure by default.

2. Never commit Secret objects to source control alongside application code.

3. By default, Secrets are stored unencrypted in etcd. To secure them, you should enable encryption at rest in the Kubernetes cluster.

4. Anyone with permission to create pods or deployments in a namespace can potentially access its Secrets. Mitigate this by applying least-privilege 
access control using RBAC.

5. Consider using external secret management solutions like AWS Secrets Manager, Azure Key Vault, GCP Secret Manager, or HashiCorp Vault for enhanced security.

-----------------------------------------------


kubectl get secrets
No resources found in default namespace.




vim web-pod.yaml
[root@client1 ahmad]# cat web-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: webapp-pod
  namespace: default
  labels:
    name: webapp-pod
spec:
  containers:
    - name: webapp
      image: kodekloud/simple-webapp-mysql


cat web-pod.yaml (This one should be used as it conatins secrets now)
apiVersion: v1
kind: Pod
metadata:
  name: webapp-pod
  namespace: default
  labels:
    name: webapp-pod
spec:
  containers:
    - name: webapp
      image: kodekloud/simple-webapp-mysql
      envFrom:
        - secretRef:
            name: db-secret





 kubectl apply -f web-pod.yaml
pod/webapp-pod created


kubectl get po
NAME         READY   STATUS    RESTARTS   AGE
webapp-pod   1/1     Running   0          98s


-----------------------------------------------

vim web-app-pod.yaml
[root@client1 ahmad]# cat web-app-pod.yaml
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
  namespace: default
spec:
  type: NodePort
  selector:
    name: webapp-pod
  ports:

    - port: 8080
      targetPort: 8080
      nodePort: 30080
      protocol: TCP



 kubectl apply -f web-app-pod.yaml
service/webapp-service created
[root@client1 ahmad]# kubectl get svc
NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
kubernetes       ClusterIP   10.96.0.1       <none>        443/TCP          4d22h
webapp-service   NodePort    10.96.151.164   <none>        8080:30080/TCP   6s

-----------------------------------------------


kubectl get nodes -o wide
NAME                       STATUS   ROLES           AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE                         KERNEL-VERSION          CONTAINER-RUNTIME
my-cluster-control-plane   Ready    control-plane   6d    v1.32.2   172.25.0.2    <none>        Debian GNU/Linux 12 (bookworm)   5.14.0-542.el9.x86_64   containerd://2.0.2
my-cluster-worker          Ready    <none>          6d    v1.32.2   172.25.0.3    <none>        Debian GNU/Linux 12 (bookworm)   5.14.0-542.el9.x86_64   containerd://2.0.2



kubectl get svc -o wide
NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE     SELECTOR
kubernetes       ClusterIP   10.96.0.1       <none>        443/TCP          4d22h   <none>
webapp-service   NodePort    10.96.151.164   <none>        8080:30080/TCP   4m13s   name=webapp-pod



172.25.0.3:30080   (This connection is failed!)

-----------------------------------------------

cat mysql-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: mysql
  labels:
    name: mysql
spec:
  containers:
    - name: mysql
      image: mysql:8.0
      ports:
        - containerPort: 3306
      env:
        - name: MYSQL_ROOT_PASSWORD
          value: "password123"
      args: ["--default-authentication-plugin=mysql_native_password", "--ssl=0"]
      volumeMounts:
        - name: init-script
          mountPath: /docker-entrypoint-initdb.d
  volumes:
    - name: init-script
      configMap:
        name: mysql-init






kubectl apply -f mysql-pod.yaml
pod/mysql created



cat mysql-pod-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: sql01
  namespace: default
spec:
  selector:
    name: mysql
  ports:
    - port: 3306
      targetPort: 3306
      protocol: TCP
  type: ClusterIP


 kubectl apply -f mysql-pod-svc.yaml
service/sql01 created




kubectl get po,svc
NAME             READY   STATUS              RESTARTS        AGE
pod/mysql        0/1     ContainerCreating   0               20s
pod/webapp-pod   1/1     Running             2 (6m47s ago)   14m

NAME                     TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
service/kubernetes       ClusterIP   10.96.0.1       <none>        443/TCP          4d23h
service/sql01            ClusterIP   10.96.75.119    <none>        3306/TCP         11s
service/webapp-service   NodePort    10.96.151.164   <none>        8080:30080/TCP   14m


-----------------------------------------------

kubectl create secret generic db-secret --from-literal=DB_Host=sql01 --from-literal=DB_User=root --from-literal=DB_Password=password123
secret/db-secret created
[root@client1 ahmad]# kubectl get secrets
NAME        TYPE     DATA   AGE
db-secret   Opaque   3      8s


kubectl describe secret db-secret
Name:         db-secret
Namespace:    default
Labels:       <none>
Annotations:  <none>

Type:  Opaque

Data
====
DB_Host:      5 bytes
DB_Password:  11 bytes
DB_User:      4 bytes




	(kubectl describe po webapp-pod ---->>>  (We can confirm from here that secret will be embedded in it)


-----------------------------------------------

kubectl describe svc webapp-service
Name:                     webapp-service
Namespace:                default
Labels:                   <none>
Annotations:              <none>
Selector:                 name=webapp-pod
Type:                     NodePort
IP Family Policy:         SingleStack
IP Families:              IPv4
IP:                       10.96.151.164
IPs:                      10.96.151.164
Port:                     <unset>  8080/TCP
TargetPort:               8080/TCP
NodePort:                 <unset>  30080/TCP
Endpoints:                10.244.1.4:8080
Session Affinity:         None
External Traffic Policy:  Cluster
Internal Traffic Policy:  Cluster
Events:                   <none>


-----------------------------------------------

vim mysql-init.sql
[root@client1 ahmad]# cat mysql-init.sql
ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'password123';
FLUSH PRIVILEGES;

kubectl create configmap mysql-init --from-file=mysql-init.sql
configmap/mysql-init created



-----------------------------------------------


 curl http://172.25.0.3:30080
<!doctype html>
<title>Hello from Flask</title>
<body style="background: #39b54b;"></body>
<div style="color: #e4e4e4;
    text-align:  center;
    height: 90px;
    vertical-align:  middle;">


    <img src="/static/img/success.jpg">
    <h3> Successfully connected to the MySQL database.</h3>



    <h2> Environment Variables: DB_Host=sql01; DB_Database=Not Set; DB_User=root; DB_Password=password123;  </h2>



    <p> From webapp-pod!</p>



---------------------------------------------
